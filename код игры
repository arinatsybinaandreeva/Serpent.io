import pygame
import random
import math
import sys
import time
import json
import os

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Pygame
pygame.init()
pygame.mixer.init()

# –ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º
info = pygame.display.Info()
WIDTH, HEIGHT = info.current_w, info.current_h
screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.FULLSCREEN)
pygame.display.set_caption('Serpent.io')

# –¶–≤–µ—Ç–∞
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
PURPLE = (128, 0, 128)
ORANGE = (255, 165, 0)
CYAN = (0, 255, 255)
PINK = (255, 192, 203)
GOLD = (255, 215, 0)
SILVER = (192, 192, 192)
DARK_BLUE = (0, 0, 100)
LIGHT_BLUE = (100, 100, 255)
BRONZE = (205, 127, 50)
LIGHT_GREEN = (144, 238, 144)
MAGENTA = (255, 0, 255)
LIME = (0, 255, 0)
DARK_GREEN = (0, 100, 0)
DARK_RED = (139, 0, 0)
LIGHT_PURPLE = (200, 100, 255)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä—ã
GRID_SIZE = 25
CAMERA_WIDTH, CAMERA_HEIGHT = WIDTH, HEIGHT
MAP_WIDTH, MAP_HEIGHT = 4000, 4000

clock = pygame.time.Clock()

# –ó–∞–≥—Ä—É–∑–∫–∞ —à—Ä–∏—Ñ—Ç–æ–≤
try:
    title_font = pygame.font.Font('arial.ttf', 48)
    large_font = pygame.font.Font('arial.ttf', 36)
    normal_font = pygame.font.Font('arial.ttf', 28)
    small_font = pygame.font.Font('arial.ttf', 22)
    very_small_font = pygame.font.Font('arial.ttf', 16)
except:
    title_font = pygame.font.SysFont('Arial', 48)
    large_font = pygame.font.SysFont('Arial', 36)
    normal_font = pygame.font.SysFont('Arial', 28)
    small_font = pygame.font.SysFont('Arial', 22)
    very_small_font = pygame.font.SysFont('Arial', 16)

# –†–µ–∂–∏–º—ã –∏–≥—Ä—ã
GAME_MODES = [
    {'name': 'EASY', 'bots': 20, 'speed': 4, 'score_multiplier': 1, 
     'bot_intelligence': 0.8, 'bot_speed': 0.7, 'food_amount': 100, 'bot_size_variation': 1.2},
    {'name': 'NORMAL', 'bots': 40, 'speed': 5, 'score_multiplier': 2, 
     'bot_intelligence': 0.9, 'bot_speed': 0.8, 'food_amount': 150, 'bot_size_variation': 1.3},
    {'name': 'HARD', 'bots': 60, 'speed': 6, 'score_multiplier': 3, 
     'bot_intelligence': 1.0, 'bot_speed': 0.9, 'food_amount': 200, 'bot_size_variation': 1.4},
    {'name': 'EXPERT', 'bots': 80, 'speed': 7, 'score_multiplier': 5, 
     'bot_intelligence': 1.2, 'bot_speed': 1.0, 'food_amount': 250, 'bot_size_variation': 1.5}
]

# –°–∫–∏–Ω—ã –∑–º–µ–π–∫–∏
SNAKE_SKINS = [
    {'name': '–ù–∞—á–∏–Ω–∞—é—â–∏–π', 'color': GREEN, 'pattern': None, 'price': 0, 'unlocked': True, 'description': '–ë–∞–∑–æ–≤—ã–π —Å–∫–∏–Ω'},
    {'name': '–û—Ö–æ—Ç–Ω–∏–∫', 'color': BLUE, 'pattern': None, 'price': 10000, 'unlocked': False, 'description': '+10% –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏'},
    {'name': '–í–æ–∏–Ω', 'color': RED, 'pattern': None, 'price': 30000, 'unlocked': False, 'description': '+20% –∫ –¥–ª–∏–Ω–µ'},
    {'name': '–ú–∞—Å—Ç–µ—Ä', 'color': PURPLE, 'pattern': None, 'price': 50000, 'unlocked': False, 'description': '+15% –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –¥–ª–∏–Ω–µ'},
    {'name': '–õ–µ–≥–µ–Ω–¥–∞', 'color': GOLD, 'pattern': None, 'price': 100000, 'unlocked': False, 'description': '+25% –∫–æ –≤—Å–µ–º –ø–æ–∫–∞–∑–∞—Ç–µ–ª—è–º'},
    {'name': '–ó–µ–±—Ä–∞', 'pattern': [WHITE, BLACK], 'price': 20000, 'unlocked': False, 'description': '–ß–µ—Ä–Ω–æ-–±–µ–ª—ã–π –ø–æ–ª–æ—Å–∞—Ç—ã–π'},
]

# –ù–∏–∫–∏ –¥–ª—è –±–æ—Ç–æ–≤
BOT_NAMES = [
    "–¢–µ–Ω—å", "–ü—Ä–∏–∑—Ä–∞–∫", "–•–∏—â–Ω–∏–∫", "–û—Ö–æ—Ç–Ω–∏–∫", "–í–æ–∏–Ω", "–£–±–∏–π—Ü–∞", "–ù–∏–Ω–¥–∑—è", "–°–∞–º—É—Ä–∞–π",
    "–ì–ª–∞–¥–∏–∞—Ç–æ—Ä", "–¢–∏—Ç–∞–Ω", "–ì–æ–ª–∏–∞—Ñ", "–¶–∏–∫–ª–æ–ø", "–§–µ–Ω–∏–∫—Å", "–î—Ä–∞–∫–æ–Ω", "–ì—Ä–∏—Ñ–æ–Ω", "–ì–∏–¥—Ä–∞",
    "–í–∞—Å–∏–ª–∏—Å–∫", "–ö—Ä–∞–∫–µ–Ω", "–í—É–ª–∫–∞–Ω", "–¢–æ—Ä–Ω–∞–¥–æ", "–¶—É–Ω–∞–º–∏", "–£—Ä–∞–≥–∞–Ω", "–ú–æ–ª–Ω–∏—è", "–í–∏—Ö—Ä—å",
    "–ë–µ—Ä—Å–µ—Ä–∫", "–í–∞—Ä–≤–∞—Ä", "–†—ã—Ü–∞—Ä—å", "–ü–∞–ª–∞–¥–∏–Ω", "–†–∞–∑–±–æ–π–Ω–∏–∫", "–ú–∞–≥", "–ñ—Ä–µ—Ü", "–î—Ä—É–∏–¥"
]

# –§–∞–π–ª –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
STATS_FILE = "snake_profile.json"

def load_stats():
    if os.path.exists(STATS_FILE):
        try:
            with open(STATS_FILE, 'r', encoding='utf-8') as f:
                stats = json.load(f)
                if 'unlocked_skins' not in stats:
                    stats['unlocked_skins'] = [0]
                if 'selected_skin' not in stats:
                    stats['selected_skin'] = 0
                return stats
        except:
            return create_default_stats()
    return create_default_stats()

def create_default_stats():
    return {
        'player_name': '–ò–≥—Ä–æ–∫',
        'total_score': 0,
        'total_games': 0,
        'total_kills': 0,
        'max_score': 0,
        'max_kills': 0,
        'unlocked_skins': [0],
        'coins': 0,
        'rating': 1000,
        'games_won': 0,
        'time_played': 0,
        'top_10_finishes': 0,
        'selected_skin': 0
    }

def save_stats(stats):
    with open(STATS_FILE, 'w', encoding='utf-8') as f:
        json.dump(stats, f, ensure_ascii=False, indent=2)

def unlock_skin(stats, skin_index):
    if skin_index < len(SNAKE_SKINS):
        skin = SNAKE_SKINS[skin_index]
        if skin_index not in stats['unlocked_skins'] and stats['coins'] >= skin['price']:
            stats['coins'] -= skin['price']
            stats['unlocked_skins'].append(skin_index)
            stats['selected_skin'] = skin_index
            save_stats(stats)
            return True
    return False

# –°–æ–∑–¥–∞–µ–º –∑–≤—É–∫ –ø–æ–µ–¥–∞–Ω–∏—è –µ–¥—ã
try:
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–æ—Å—Ç–æ–π –∑–≤—É–∫ –ø–æ–µ–¥–∞–Ω–∏—è
    sample_rate = 44100
    duration = 0.2
    samples = int(sample_rate * duration)
    buffer = bytearray()
    
    for i in range(samples):
        # –°–æ–∑–¥–∞–µ–º –∑–≤—É–∫ "—Ö—Ä—É—Å—Ç–∞" - –∫–æ–º–±–∏–Ω–∞—Ü–∏—è –≤—ã—Å–æ–∫–∏—Ö —á–∞—Å—Ç–æ—Ç
        value = int(127 + 100 * math.sin(2 * math.pi * 880 * i / sample_rate) * 
                   math.exp(-i / (sample_rate * duration * 0.5)))
        buffer.append(max(0, min(255, value)))
    
    eat_sound = pygame.mixer.Sound(buffer=bytes(buffer))
    crash_sound = pygame.mixer.Sound(buffer=bytearray([127] * 1000))
    boost_sound = pygame.mixer.Sound(buffer=bytearray([127] * 1000))
    kill_sound = pygame.mixer.Sound(buffer=bytearray([127] * 1000))
    coin_sound = pygame.mixer.Sound(buffer=bytearray([127] * 1000))
    respawn_sound = pygame.mixer.Sound(buffer=bytearray([127] * 1000))
    unlock_sound = pygame.mixer.Sound(buffer=bytearray([127] * 1000))
except:
    class DummySound:
        def play(self): pass
    eat_sound = crash_sound = boost_sound = kill_sound = coin_sound = respawn_sound = unlock_sound = DummySound()

class Camera:
    def __init__(self):
        self.x = 0
        self.y = 0
        self.width = CAMERA_WIDTH
        self.height = CAMERA_HEIGHT
        self.zoom = 1.0
    
    def update(self, target_x, target_y, target_speed):
        self.x += (target_x - self.x - self.width // 2) * 0.08
        self.y += (target_y - self.y - self.height // 2) * 0.08
        self.zoom = 0.9 + min(target_speed, 1.5) * 0.1
        self.x = max(0, min(self.x, MAP_WIDTH - self.width))
        self.y = max(0, min(self.y, MAP_HEIGHT - self.height))
    
    def world_to_screen(self, x, y):
        zoomed_x = (x - self.x) * self.zoom + self.width * (1 - self.zoom) / 2
        zoomed_y = (y - self.y) * self.zoom + self.height * (1 - self.zoom) / 2
        return int(zoomed_x), int(zoomed_y)

class Snake:
    def __init__(self, x, y, skin_index, name="–ò–≥—Ä–æ–∫", is_bot=False, initial_length=4, speed=1.0):
        skin = SNAKE_SKINS[skin_index]
        self.positions = [(x, y)]
        self.direction = self.get_random_direction()
        self.length = initial_length
        self.score = initial_length - 1
        self.skin_index = skin_index
        self.skin = skin
        self.name = name
        self.is_bot = is_bot
        self.speed = speed * 0.3
        self.boost_timer = 0
        self.kills = 0
        self.is_alive = True
        self.rank = 0
        self.invincible_timer = 120  # 2 —Å–µ–∫—É–Ω–¥—ã –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç–∏ –¥–ª—è –≤—Å–µ—Ö
        self.respawn_timer = 0
        self.spawn_time = time.time()  # –í—Ä–µ–º—è –ø–æ—è–≤–ª–µ–Ω–∏—è
        
        for i in range(1, initial_length):
            new_x = x - i * self.direction[0] * GRID_SIZE
            new_y = y - i * self.direction[1] * GRID_SIZE
            self.positions.append((new_x, new_y))
    
    def get_random_direction(self):
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        return random.choice(directions)
    
    def get_head_position(self):
        return self.positions[0]
    
    def get_speed(self):
        base_speed = self.speed
        if self.boost_timer > 0:
            base_speed *= 2.0
        return base_speed
    
    def move(self):
        if not self.is_alive:
            self.respawn_timer -= 1
            if self.respawn_timer <= 0:
                self.respawn()
            return
            
        head_x, head_y = self.get_head_position()
        dir_x, dir_y = self.direction
        
        new_x = head_x + dir_x * self.get_speed() * GRID_SIZE
        new_y = head_y + dir_y * self.get_speed() * GRID_SIZE
        
        # –°–ú–ï–†–¢–¨ –ü–†–ò –ö–ê–°–ê–ù–ò–ò –ì–†–ê–ù–ò–¶
        if new_x < 0 or new_x >= MAP_WIDTH or new_y < 0 or new_y >= MAP_HEIGHT:
            self.kill()
            return
        
        self.positions.insert(0, (new_x, new_y))
        if len(self.positions) > self.length:
            self.positions.pop()
        
        if self.boost_timer > 0:
            self.boost_timer -= 1
        
        if self.invincible_timer > 0:
            self.invincible_timer -= 1
    
    def change_direction(self, direction):
        if direction != (0, 0) and (direction[0] * -1, direction[1] * -1) != self.direction:
            self.direction = direction
    
    def grow(self, amount=1, play_sound=True):
        self.length += amount
        self.score += amount
        if play_sound:
            eat_sound.play()
    
    def apply_boost(self):
        self.boost_timer = 120
        boost_sound.play()
    
    def kill(self):
        if self.invincible_timer > 0:
            return False
            
        self.is_alive = False
        self.respawn_timer = 180
        crash_sound.play()
        return max(3, self.length // 3)
    
    def respawn(self):
        self.is_alive = True
        self.positions = [(random.randint(500, MAP_WIDTH-500), random.randint(500, MAP_HEIGHT-500))]
        self.direction = self.get_random_direction()
        self.length = max(3, self.length // 2)
        self.score = self.length - 1
        self.invincible_timer = 120
        
        for i in range(1, self.length):
            new_x = self.positions[0][0] - i * self.direction[0] * GRID_SIZE
            new_y = self.positions[0][1] - i * self.direction[1] * GRID_SIZE
            self.positions.append((new_x, new_y))
        
        respawn_sound.play()
    
    def is_invincible(self):
        return self.invincible_timer > 0
    
    def get_segment_color(self, segment_index):
        if self.skin['pattern'] is None:
            return self.skin['color']
        else:
            pattern = self.skin['pattern']
            return pattern[segment_index % len(pattern)]
    
    def draw(self, surface, camera):
        if not self.is_alive:
            return
            
        for i, (x, y) in enumerate(self.positions):
            screen_x, screen_y = camera.world_to_screen(x, y)
            size = int(GRID_SIZE * camera.zoom * (0.9 if self.is_bot else 1.0))
            
            alpha = 255
            if self.is_invincible():
                alpha = 150 + int(105 * math.sin(time.time() * 10))
            
            segment_color = self.get_segment_color(i)
            
            if i == 0:  # –ì–æ–ª–æ–≤–∞
                # –°–æ–∑–¥–∞–µ–º –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å —Å –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª–æ–º –¥–ª—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
                s = pygame.Surface((size, size), pygame.SRCALPHA)
                pygame.draw.circle(s, (*segment_color, alpha), (size//2, size//2), size//2)
                surface.blit(s, (screen_x - size//2, screen_y - size//2))
                
                eye_size = max(2, size // 5)
                dir_x, dir_y = self.direction
                
                if dir_x != 0 or dir_y != 0:
                    pygame.draw.circle(surface, WHITE, 
                                     (screen_x + dir_x * size//3, screen_y + dir_y * size//3), 
                                     eye_size)
                    pygame.draw.circle(surface, BLACK, 
                                     (screen_x + dir_x * size//3, screen_y + dir_y * size//3), 
                                     eye_size // 2)
                
                pygame.draw.circle(surface, BLACK, (screen_x, screen_y), size // 2, 1)
            else:  # –¢–µ–ª–æ
                s = pygame.Surface((size-2, size-2), pygame.SRCALPHA)
                pygame.draw.circle(s, (*segment_color, alpha), ((size-2)//2, (size-2)//2), (size-2)//2)
                surface.blit(s, (screen_x - (size-2)//2, screen_y - (size-2)//2))
                pygame.draw.circle(surface, BLACK, (screen_x, screen_y), (size-2)//2, 1)
        
        # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–º–µ–Ω–∏
        if not self.is_bot or self.rank <= 15:
            head_x, head_y = camera.world_to_screen(*self.get_head_position())
            name_color = GOLD if self.rank == 1 else SILVER if self.rank == 2 else BRONZE if self.rank == 3 else WHITE
            
            name_text = small_font.render(f'{self.rank}. {self.name} ({self.score})', True, name_color)
            surface.blit(name_text, (head_x - name_text.get_width()//2, head_y - size - 20))

class Food:
    def __init__(self, position=None, food_type=None, is_special=False):
        if position:
            self.position = position
        else:
            # –ï–¥–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Ä–µ–∂–µ –∏ –¥–∞–ª—å—à–µ –æ—Ç –∫—Ä–∞–µ–≤
            self.position = (random.randint(300, MAP_WIDTH-300), random.randint(300, MAP_HEIGHT-300))
        
        # –£–º–µ–Ω—å—à–∞–µ–º —á–∞—Å—Ç–æ—Ç—É —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π –µ–¥—ã
        self.type = food_type if food_type else random.choices(
            ['normal', 'boost', 'bonus', 'coin'], 
            weights=[15, 1, 0.3, 0.2], k=1
        )[0]
        
        self.is_special = is_special
        self.pulse_timer = 0
        
        self.colors = {
            'normal': RED, 
            'boost': CYAN, 
            'bonus': YELLOW, 
            'coin': GOLD
        }
        self.sizes = {'normal': 0.5, 'boost': 0.7, 'bonus': 0.9, 'coin': 0.4}
        self.value = {'normal': 1, 'boost': 2, 'bonus': 5, 'coin': 10}
    
    def update(self):
        self.pulse_timer += 1
    
    def draw(self, surface, camera):
        x, y = self.position
        screen_x, screen_y = camera.world_to_screen(x, y)
        
        if self.is_special:
            pulse = 0.5 + 0.2 * math.sin(self.pulse_timer * 0.1)
            size = int(GRID_SIZE * 1.2 * camera.zoom * pulse)
            pygame.draw.circle(surface, GREEN, (screen_x, screen_y), size)
            pygame.draw.circle(surface, WHITE, (screen_x, screen_y), size, 2)
        else:
            color = self.colors[self.type]
            size = int(GRID_SIZE * self.sizes[self.type] * camera.zoom)
            pygame.draw.circle(surface, color, (screen_x, screen_y), size)
            if self.type != 'normal':
                pygame.draw.circle(surface, WHITE, (screen_x, screen_y), size, 1)

class AdvancedBot:
    def __init__(self, name, intelligence=0.8, speed=1.0, size_variation=1.0):
        x = random.randint(500, MAP_WIDTH-500)
        y = random.randint(500, MAP_HEIGHT-500)
        
        skin_index = random.randint(0, len(SNAKE_SKINS) - 1)
        base_size = 6
        size_modifier = 1.0
        initial_length = max(5, int(base_size * size_modifier))
        
        self.snake = Snake(x, y, skin_index, name, True, initial_length, speed)
        self.intelligence = intelligence
        self.target_food = None
        self.target_snake = None
        self.state = 'eat'
        self.state_timer = random.randint(60, 120)
        self.last_food_time = time.time()
        self.last_direction_change = 0
        self.avoid_wall_timer = 0
        self.strategy_timer = 0
        self.death_time = 0
        self.memory = {}
        self.path = []
        self.aggression = 0.6 + (intelligence - 0.8) * 1.0
        self.caution = 1.0 - self.aggression * 0.4
        self.survival_time = time.time()
        
    def update(self, foods, player_snake, other_snakes):
        if not self.snake.is_alive:
            if self.death_time == 0:
                self.death_time = time.time()
            return
            
        # –í —Ä–µ–∂–∏–º–µ –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç–∏ –ø—Ä–æ—Å—Ç–æ –¥–≤–∏–≥–∞–µ–º—Å—è –∏ –∏—â–µ–º –µ–¥—É
        if self.snake.is_invincible():
            head_x, head_y = self.snake.get_head_position()
            self.advanced_hunt_food(foods, head_x, head_y)
            self.advanced_avoid_walls(head_x, head_y)
            self.snake.move()
            self.eat_food(foods, head_x, head_y)
            return
            
        head_x, head_y = self.snake.get_head_position()
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏
        self.update_memory(foods, player_snake, other_snakes)
        
        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        self.strategy_timer -= 1
        if self.strategy_timer <= 0:
            self.choose_strategy(player_snake, other_snakes)
            self.strategy_timer = random.randint(50, 100)
        
        # –ò–∑–±–µ–≥–∞–Ω–∏–µ —Å—Ç–µ–Ω
        self.advanced_avoid_walls(head_x, head_y)
        
        # –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        if self.state == 'eat':
            self.advanced_hunt_food(foods, head_x, head_y)
        elif self.state == 'attack':
            self.advanced_attack_enemy(player_snake, other_snakes, head_x, head_y)
        elif self.state == 'escape':
            self.advanced_escape_danger(player_snake, other_snakes, head_x, head_y)
        elif self.state == 'ambush':
            self.ambush_strategy(player_snake, other_snakes, head_x, head_y)
        elif self.state == 'patrol':
            self.patrol_strategy(head_x, head_y)
        elif self.state == 'survive':
            self.survival_strategy(head_x, head_y)
        
        # –°–º–µ–Ω–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        self.last_direction_change -= 1
        if self.last_direction_change <= 0:
            self.smart_direction_change()
            self.last_direction_change = random.randint(20, 50)
        
        self.state_timer -= 1
        self.snake.move()
        
        # –ë–æ—Ç—ã –µ–¥—è—Ç –µ–¥—É
        self.eat_food(foods, head_x, head_y)
    
    def survival_strategy(self, head_x, head_y):
        """–°—Ç—Ä–∞—Ç–µ–≥–∏—è –≤—ã–∂–∏–≤–∞–Ω–∏—è - –∏–∑–±–µ–≥–∞–Ω–∏–µ –æ–ø–∞—Å–Ω–æ—Å—Ç–µ–π"""
        # –ò—â–µ–º –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –º–µ—Å—Ç–æ –≤ —Ü–µ–Ω—Ç—Ä–µ –∫–∞—Ä—Ç—ã
        center_x, center_y = MAP_WIDTH // 2, MAP_HEIGHT // 2
        self.move_towards((center_x, center_y), 0.9)
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –∏–∑–±–µ–≥–∞–µ–º —Å—Ç–µ–Ω
        margin = 300
        if (head_x < margin or head_x > MAP_WIDTH - margin or
            head_y < margin or head_y > MAP_HEIGHT - margin):
            escape_dir = (1 if center_x > head_x else -1, 
                        1 if center_y > head_y else -1)
            self.snake.change_direction(escape_dir)
    
    def update_memory(self, foods, player_snake, other_snakes):
        """–ó–∞–ø–æ–º–∏–Ω–∞–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –µ–¥—ã –∏ –≤—Ä–∞–≥–æ–≤"""
        current_time = time.time()
        
        # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –µ–¥—É
        for food in foods:
            if food.type != 'normal' or random.random() < 0.4:
                self.memory[f'food_{id(food)}'] = {
                    'position': food.position,
                    'type': food.type,
                    'timestamp': current_time,
                    'priority': 2.0 if food.type != 'normal' else 1.0
                }
        
        # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –≤—Ä–∞–≥–æ–≤
        all_enemies = [player_snake] + [bot.snake for bot in other_snakes if bot != self]
        for enemy in all_enemies:
            if enemy.is_alive and enemy != self.snake:
                danger_level = enemy.score / max(1, self.snake.score)
                self.memory[f'enemy_{id(enemy)}'] = {
                    'position': enemy.get_head_position(),
                    'score': enemy.score,
                    'direction': enemy.direction,
                    'timestamp': current_time,
                    'danger': danger_level
                }
        
        # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—É—é –ø–∞–º—è—Ç—å
        to_delete = []
        for key, data in self.memory.items():
            max_age = 15 / data.get('priority', 1.0)
            if current_time - data['timestamp'] > max_age:
                to_delete.append(key)
        for key in to_delete:
            del self.memory[key]
    
    def choose_strategy(self, player_snake, other_snakes):
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"""
        hunger_level = (time.time() - self.last_food_time) / 2.0
        all_snakes = [player_snake] + [bot.snake for bot in other_snakes if bot != self]
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ–ø–∞—Å–Ω–æ—Å—Ç—å
        immediate_danger = False
        for snake in all_snakes:
            if (snake != self.snake and snake.is_alive and not snake.is_invincible() and
                snake.score > self.snake.score * (1.5 - self.caution * 0.3)):
                
                dist = math.hypot(snake.get_head_position()[0] - self.snake.get_head_position()[0],
                                 snake.get_head_position()[1] - self.snake.get_head_position()[1])
                if dist < 300:
                    immediate_danger = True
                    break
        
        if immediate_danger:
            self.state = 'escape'
            return
        
        # –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        strategies = []
        
        if hunger_level > 4.0 or self.snake.score < 25:
            strategies.extend(['eat'] * (10 + int(self.intelligence * 5)))
        
        weak_enemies = any(snake for snake in all_snakes 
                          if snake != self.snake and snake.is_alive and 
                          snake.score < self.snake.score * 0.7)
        
        if weak_enemies and self.snake.score > 20:
            strategies.extend(['attack'] * (8 + int(self.aggression * 10)))
        
        if self.snake.score > 35 and random.random() < self.aggression:
            strategies.extend(['ambush'] * (6 + int(self.intelligence * 4)))
        
        survival_time = time.time() - self.survival_time
        if survival_time > 30 and random.random() < self.caution:
            strategies.extend(['patrol'] * (5 + int(self.caution * 5)))
        
        if not strategies or random.random() < 0.1:
            strategies.extend(['patrol'] * 4)
        
        if strategies:
            self.state = random.choice(strategies)
        else:
            self.state = 'eat'
    
    def advanced_hunt_food(self, foods, head_x, head_y):
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è –æ—Ö–æ—Ç–∞ –∑–∞ –µ–¥–æ–π"""
        best_target = None
        best_score = -float('inf')
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ–¥—É –≤ –ø–∞–º—è—Ç–∏
        for key, data in self.memory.items():
            if key.startswith('food_'):
                fx, fy = data['position']
                dist = math.hypot(fx - head_x, fy - head_y)
                
                if dist < 1800:
                    food_value = 1
                    if data['type'] == 'boost': food_value = 4
                    if data['type'] == 'bonus': food_value = 6
                    if data['type'] == 'coin': food_value = 3
                    
                    priority = data.get('priority', 1.0)
                    score = (food_value * self.intelligence * priority) / (dist + 1)
                    
                    if score > best_score:
                        best_score = score
                        best_target = data['position']
        
        # –ï—Å–ª–∏ –≤ –ø–∞–º—è—Ç–∏ –Ω–µ—Ç —Ö–æ—Ä–æ—à–µ–π –µ–¥—ã, –∏—â–µ–º –±–ª–∏–∂–∞–π—à—É—é
        if best_target is None and foods:
            for food in foods:
                fx, fy = food.position
                dist = math.hypot(fx - head_x, fy - head_y)
                
                if dist < 1000:
                    food_value = 1
                    if food.type == 'boost': food_value = 4
                    if food.type == 'bonus': food_value = 6
                    if food.type == 'coin': food_value = 3
                    
                    score = (food_value * self.intelligence) / (dist + 1)
                    
                    if score > best_score:
                        best_score = score
                        best_target = food.position
        
        if best_target:
            accuracy = 0.96 + self.intelligence * 0.03
            self.move_towards(best_target, accuracy)
        else:
            if random.random() < 0.5:
                self.patrol_strategy(head_x, head_y)
    
    def advanced_attack_enemy(self, player_snake, other_snakes, head_x, head_y):
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è –∞—Ç–∞–∫–∞ –≤—Ä–∞–≥–æ–≤"""
        targets = [player_snake] + [bot.snake for bot in other_snakes if bot != self]
        best_target = None
        best_score = -float('inf')
        
        for target in targets:
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ—É—è–∑–≤–∏–º—ã—Ö —Ü–µ–ª–µ–π
            if target.is_invincible():
                continue
                
            if (target != self.snake and target.is_alive and
                self.snake.score > target.score * (0.7 + self.aggression * 0.3)):
                
                tx, ty = target.get_head_position()
                dist = math.hypot(tx - head_x, ty - head_y)
                
                if dist < 1000:
                    score = (target.score * self.aggression) / (dist + 1)
                    
                    tdx, tdy = target.direction
                    predicted_pos = (tx + tdx * dist * 0.1, ty + tdy * dist * 0.1)
                    
                    if score > best_score:
                        best_score = score
                        best_target = predicted_pos
        
        if best_target:
            self.move_towards(best_target, 0.9 + self.intelligence * 0.1)
            
            if best_score > 5 and random.random() < self.aggression:
                tx, ty = best_target
                intercept_x = tx + (tx - head_x) * 0.2
                intercept_y = ty + (ty - head_y) * 0.2
                self.move_towards((intercept_x, intercept_y), 0.8)
        else:
            self.state = 'eat'
    
    def advanced_escape_danger(self, player_snake, other_snakes, head_x, head_y):
        """–£–ª—É—á—à–µ–Ω–Ω–æ–µ –±–µ–≥—Å—Ç–≤–æ –æ—Ç –æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        all_snakes = [player_snake] + [bot.snake for bot in other_snakes if bot != self]
        dangers = []
        
        for danger in all_snakes:
            if (danger != self.snake and danger.is_alive and 
                danger.score > self.snake.score * (1.1 - self.caution * 0.1)):
                
                dx, dy = danger.get_head_position()
                dist = math.hypot(dx - head_x, dy - head_y)
                
                if dist < 600:
                    dangers.append((danger, dist, (dx, dy)))
        
        if dangers:
            dangers.sort(key=lambda x: x[1])
            most_dangerous = dangers[0]
            dx, dy = most_dangerous[2]
            
            escape_dir = (head_x - dx, head_y - dy)
            length = math.hypot(escape_dir[0], escape_dir[1])
            
            if length > 0:
                escape_dir = (escape_dir[0]/length, escape_dir[1]/length)
                
                safe_directions = self.find_safe_directions(head_x, head_y, escape_dir)
                
                if safe_directions:
                    best_dir = max(safe_directions, key=lambda x: x[1])
                    self.snake.change_direction((round(best_dir[0][0]), round(best_dir[0][1])))
                else:
                    self.snake.change_direction((round(escape_dir[0]), round(escape_dir[1])))
        else:
            self.state = 'eat'
    
    def ambush_strategy(self, player_snake, other_snakes, head_x, head_y):
        """–°—Ç—Ä–∞—Ç–µ–≥–∏—è –∑–∞—Å–∞–¥—ã"""
        targets = [player_snake] + [bot.snake for bot in other_snakes if bot != self]
        vulnerable_targets = []
        
        for target in targets:
            if (target != self.snake and target.is_alive and
                target.score < self.snake.score * 0.6):
                
                tx, ty = target.get_head_position()
                dist = math.hypot(tx - head_x, ty - head_y)
                
                if dist < 1200:
                    vulnerable_targets.append((target, dist))
        
        if vulnerable_targets:
            vulnerable_targets.sort(key=lambda x: x[1])
            target, dist = vulnerable_targets[0]
            
            tx, ty = target.get_head_position()
            tdx, tdy = target.direction
            intercept_pos = (tx + tdx * dist * 0.3, ty + tdy * dist * 0.3)
            
            self.move_towards(intercept_pos, 0.85 + self.intelligence * 0.15)
        else:
            self.state = 'patrol'
    
    def patrol_strategy(self, head_x, head_y):
        """–°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏—è"""
        if not self.path or random.random() < 0.1:
            self.path = []
            for _ in range(3):
                point_x = random.randint(500, MAP_WIDTH - 500)
                point_y = random.randint(500, MAP_HEIGHT - 500)
                self.path.append((point_x, point_y))
        
        if self.path:
            target = self.path[0]
            dist = math.hypot(target[0] - head_x, target[1] - head_y)
            
            if dist < 200:
                self.path.pop(0)
            else:
                self.move_towards(target, 0.8)
    
    def find_safe_directions(self, head_x, head_y, preferred_dir):
        """–ù–∞—Ö–æ–¥–∏—Ç –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è"""
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        safe_directions = []
        
        for direction in directions:
            new_x = head_x + direction[0] * 100
            new_y = head_y + direction[1] * 100
            
            if (100 <= new_x <= MAP_WIDTH - 100 and 
                100 <= new_y <= MAP_HEIGHT - 100):
                
                dot_product = direction[0] * preferred_dir[0] + direction[1] * preferred_dir[1]
                safety_score = dot_product * 0.5 + 0.5
                
                safe_directions.append((direction, safety_score))
        
        return safe_directions
    
    def advanced_avoid_walls(self, head_x, head_y):
        """–£–ª—É—á—à–µ–Ω–Ω–æ–µ –∏–∑–±–µ–≥–∞–Ω–∏–µ —Å—Ç–µ–Ω"""
        margin = 250 + int(self.intelligence * 150)
        safety_margin = margin * (1.0 + self.caution * 0.6)
        
        if (head_x < safety_margin or head_x > MAP_WIDTH - safety_margin or
            head_y < safety_margin or head_y > MAP_HEIGHT - safety_margin):
            
            center_x, center_y = MAP_WIDTH // 2, MAP_HEIGHT // 2
            escape_dir = (1 if center_x > head_x else -1, 
                        1 if center_y > head_y else -1)
            
            if random.random() < self.intelligence * 0.9:
                self.snake.change_direction(escape_dir)
            else:
                safe_dirs = self.find_safe_directions(head_x, head_y, escape_dir)
                if safe_dirs:
                    best_dir = max(safe_dirs, key=lambda x: x[1])
                    self.snake.change_direction(best_dir[0])
    
    def smart_direction_change(self):
        """–£–º–Ω–∞—è —Å–º–µ–Ω–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
        if random.random() < self.intelligence:
            head_x, head_y = self.snake.get_head_position()
            
            interesting_dirs = []
            
            for key, data in self.memory.items():
                if time.time() - data['timestamp'] < 5:
                    obj_x, obj_y = data['position']
                    dir_to_obj = (1 if obj_x > head_x else -1, 
                                1 if obj_y > head_y else -1)
                    interesting_dirs.append(dir_to_obj)
            
            if interesting_dirs:
                dir_counts = {}
                for direction in interesting_dirs:
                    dir_counts[direction] = dir_counts.get(direction, 0) + 1
                
                best_dir = max(dir_counts.items(), key=lambda x: x[1])[0]
                self.snake.change_direction(best_dir)
                return
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        current_dir = self.snake.direction
        opposite_dir = (-current_dir[0], -current_dir[1])
        
        available_dirs = [d for d in directions if d != opposite_dir]
        if available_dirs:
            new_dir = random.choice(available_dirs)
            self.snake.change_direction(new_dir)
    
    def eat_food(self, foods, head_x, head_y):
        """–ë–æ—Ç—ã –µ–¥—è—Ç –µ–¥—É –∏ —Ä–∞—Å—Ç—É—Ç"""
        for food in foods[:]:
            if not self.snake.is_alive:
                continue
                
            fx, fy = food.position
            distance = math.hypot(fx - head_x, fy - head_y)
            
            if distance < GRID_SIZE * 1.5:
                self.snake.grow(food.value[food.type], play_sound=False)
                foods.remove(food)
                if random.random() < 0.6:
                    foods.append(Food())
                self.on_eat_food()
                break
    
    def move_towards(self, target_pos, accuracy=0.9):
        if random.random() < self.intelligence * accuracy:
            tx, ty = target_pos
            hx, hy = self.snake.get_head_position()
            
            dx = 0
            dy = 0
            
            if abs(tx - hx) > GRID_SIZE * 2:
                dx = 1 if tx > hx else -1
            if abs(ty - hy) > GRID_SIZE * 2:
                dy = 1 if ty > hy else -1
            
            if dx != 0 or dy != 0:
                self.snake.change_direction((dx, dy))
    
    def on_eat_food(self):
        self.last_food_time = time.time()

def create_advanced_bots(count):
    bots = []
    for i in range(count):
        intelligence = random.uniform(0.7, 0.95)
        aggression = random.uniform(0.5, 0.9)
        speed = random.uniform(0.9, 1.1)
        
        bot = AdvancedBot(f"Bot_{i+1}", intelligence, speed)
        bot.aggression = aggression
        bot.caution = 1.0 - aggression * 0.4
        bots.append(bot)
    
    return bots

def draw_dynamic_background(surface, camera):
    surface.fill((20, 20, 50))
    
    t = time.time()
    for i in range(80):
        x = (i * 197 + t * 40) % MAP_WIDTH
        y = (i * 173 + t * 25) % MAP_HEIGHT
        sx, sy = camera.world_to_screen(x, y)
        if 0 <= sx < WIDTH and 0 <= sy < HEIGHT:
            size = 1 + math.sin(t + i) * 1.5
            brightness = 80 + int(70 * math.sin(t * 2 + i))
            pygame.draw.circle(surface, (brightness, brightness, 180), (sx, sy), size)

def show_game_over(surface, score, player_name, kills, coins_earned, final_rank, stats):
    overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, 200))
    surface.blit(overlay, (0, 0))
    
    stats['total_score'] += score
    stats['total_games'] += 1
    stats['total_kills'] += kills
    stats['coins'] += coins_earned
    stats['max_score'] = max(stats['max_score'], score)
    stats['max_kills'] = max(stats['max_kills'], kills)
    
    if final_rank == 1:
        stats['games_won'] += 1
        stats['rating'] += 50
    
    save_stats(stats)
    
    rank_color = GOLD if final_rank == 1 else SILVER if final_rank == 2 else BRONZE if final_rank == 3 else WHITE
    
    game_over_text = title_font.render('–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê', True, RED)
    rank_text = large_font.render(f'–ú–µ—Å—Ç–æ: {final_rank}', True, rank_color)
    score_text = normal_font.render(f'–°—á–µ—Ç: {score}', True, WHITE)
    kills_text = normal_font.render(f'–£–±–∏–π—Å—Ç–≤: {kills}', True, RED)
    coins_text = normal_font.render(f'–ú–æ–Ω–µ—Ç—ã: +{coins_earned}', True, GOLD)
    
    restart_text = small_font.render('R - –ù–æ–≤–∞—è –∏–≥—Ä–∞', True, GREEN)
    menu_text = small_font.render('M - –ú–µ–Ω—é', True, YELLOW)
    quit_text = small_font.render('Q - –í—ã—Ö–æ–¥', True, WHITE)
    
    y_pos = HEIGHT // 2 - 150
    surface.blit(game_over_text, (WIDTH//2 - game_over_text.get_width()//2, y_pos))
    y_pos += 70
    surface.blit(rank_text, (WIDTH//2 - rank_text.get_width()//2, y_pos))
    y_pos += 50
    surface.blit(score_text, (WIDTH//2 - score_text.get_width()//2, y_pos))
    y_pos += 40
    surface.blit(kills_text, (WIDTH//2 - kills_text.get_width()//2, y_pos))
    y_pos += 40
    surface.blit(coins_text, (WIDTH//2 - coins_text.get_width()//2, y_pos))
    
    y_pos += 60
    surface.blit(restart_text, (WIDTH//2 - restart_text.get_width()//2, y_pos))
    y_pos += 40
    surface.blit(menu_text, (WIDTH//2 - menu_text.get_width()//2, y_pos))
    y_pos += 40
    surface.blit(quit_text, (WIDTH//2 - quit_text.get_width()//2, y_pos))

def show_hud(surface, score, speed, boost_time, player_name, kills, coins, total_coins, rank, total_players, all_snakes, bots_count):
    # –û—Å–Ω–æ–≤–Ω–æ–π HUD –≤–≤–µ—Ä—Ö—É
    pygame.draw.rect(surface, (0, 0, 0, 180), (0, 0, WIDTH, 60))
    
    player_text = normal_font.render(f'{player_name}', True, WHITE)
    score_text = small_font.render(f'–°—á–µ—Ç: {score}', True, WHITE)
    kills_text = small_font.render(f'–£–±–∏–π—Å—Ç–≤: {kills}', True, RED)
    
    rank_color = GOLD if rank == 1 else SILVER if rank == 2 else CYAN if rank <= 10 else WHITE
    rank_text = large_font.render(f'{rank}/{total_players}', True, rank_color)
    
    coins_text = small_font.render(f'üí∞ {coins}', True, GOLD)
    speed_text = small_font.render(f'–°–∫–æ—Ä–æ—Å—Ç—å: {speed:.1f}x', True, WHITE)
    bots_text = small_font.render(f'–ë–æ—Ç—ã: {bots_count}', True, SILVER)
    
    surface.blit(player_text, (20, 10))
    surface.blit(score_text, (20, 35))
    surface.blit(kills_text, (150, 35))
    
    surface.blit(rank_text, (WIDTH//2 - rank_text.get_width()//2, 15))
    
    surface.blit(coins_text, (WIDTH - 150, 10))
    surface.blit(speed_text, (WIDTH - 150, 35))
    surface.blit(bots_text, (WIDTH - 250, 35))
    
    if boost_time > 0:
        boost_width = 120 * (boost_time/120)
        pygame.draw.rect(surface, (100, 100, 255), (WIDTH - 150, 55, boost_width, 5))
        boost_text = small_font.render('–¢–£–†–ë–û!', True, CYAN)
        surface.blit(boost_text, (WIDTH - 200, 52))
    
    # –¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ —Å–ø—Ä–∞–≤–∞ —Å–≤–µ—Ä—Ö—É
    show_leaderboard(surface, all_snakes)
def show_leaderboard(surface, all_snakes):
    """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤ —Å–ø—Ä–∞–≤–∞ —Å–≤–µ—Ä—Ö—É"""
    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∑–º–µ–π –ø–æ –æ—á–∫–∞–º
    sorted_snakes = sorted([s for s in all_snakes if s.is_alive], 
                          key=lambda x: x.score, reverse=True)
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ø-5 –∏–≥—Ä–æ–∫–æ–≤
    top_count = min(5, len(sorted_snakes))
    
    # –§–æ–Ω –¥–ª—è —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤
    leaderboard_width = 250
    leaderboard_height = top_count * 30 + 40
    pygame.draw.rect(surface, (0, 0, 0, 180), 
                   (WIDTH - leaderboard_width - 10, 70, leaderboard_width, leaderboard_height),
                   border_radius=5)
    pygame.draw.rect(surface, WHITE, 
                   (WIDTH - leaderboard_width - 10, 70, leaderboard_width, leaderboard_height),
                   2, border_radius=5)
    
    # –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
    title_text = small_font.render('–¢–û–ü –ò–ì–†–û–ö–û–í', True, GOLD)
    surface.blit(title_text, (WIDTH - leaderboard_width//2 - title_text.get_width()//2 - 10, 75))
    
    # –°–ø–∏—Å–æ–∫ –∏–≥—Ä–æ–∫–æ–≤
    for i, snake in enumerate(sorted_snakes[:top_count]):
        y_pos = 110 + i * 30
        
        # –¶–≤–µ—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –º–µ—Å—Ç–∞
        if i == 0:
            color = GOLD
        elif i == 1:
            color = SILVER
        elif i == 2:
            color = BRONZE
        else:
            color = WHITE
        
        # –ò–º—è –∏ —Å—á–µ—Ç –∏–≥—Ä–æ–∫–∞
        name_text = very_small_font.render(f'{i+1}. {snake.name}', True, color)
        score_text = very_small_font.render(str(snake.score), True, color)
        
        surface.blit(name_text, (WIDTH - leaderboard_width + 10, y_pos))
        surface.blit(score_text, (WIDTH - 50, y_pos))

def draw_button(surface, text, x, y, width, height, color, hover_color, text_color, font):
    mouse = pygame.mouse.get_pos()
    clicked = False
    
    if x <= mouse[0] <= x + width and y <= mouse[1] <= y + height:
        current_color = hover_color
        if pygame.mouse.get_pressed()[0]:
            clicked = True
            pygame.time.delay(200)
    else:
        current_color = color
    
    pygame.draw.rect(surface, current_color, (x, y, width, height), border_radius=8)
    pygame.draw.rect(surface, text_color, (x, y, width, height), 2, border_radius=8)
    
    text_surf = font.render(text, True, text_color)
    surface.blit(text_surf, (x + width//2 - text_surf.get_width()//2, y + height//2 - text_surf.get_height()//2))
    
    return clicked

def draw_snake_preview(surface, x, y, skin, size=80):
    """–†–∏—Å—É–µ—Ç –ø—Ä–µ–≤—å—é –∑–º–µ–π–∫–∏ —Å –≤—ã–±—Ä–∞–Ω–Ω—ã–º —Å–∫–∏–Ω–æ–º"""
    segments = 5
    segment_size = size // (segments * 2)
    
    # –†–∏—Å—É–µ–º –∑–º–µ–π–∫—É
    for i in range(segments):
        seg_x = x + i * segment_size * 1.5
        seg_y = y
        
        if skin['pattern'] is None:
            color = skin['color']
        else:
            color = skin['pattern'][i % len(skin['pattern'])]
        
        # –ì–æ–ª–æ–≤–∞
        if i == 0:
            pygame.draw.circle(surface, color, (int(seg_x), int(seg_y)), segment_size)
            # –ì–ª–∞–∑–∞
            pygame.draw.circle(surface, WHITE, (int(seg_x + segment_size//3), int(seg_y - segment_size//3)), segment_size//4)
            pygame.draw.circle(surface, BLACK, (int(seg_x + segment_size//3), int(seg_y - segment_size//3)), segment_size//8)
        else:
            # –¢–µ–ª–æ
            pygame.draw.circle(surface, color, (int(seg_x), int(seg_y)), segment_size - 2)
        
        # –û–±–≤–æ–¥–∫–∞
        pygame.draw.circle(surface, BLACK, (int(seg_x), int(seg_y)), segment_size if i == 0 else segment_size - 2, 1)

def get_player_name(stats):
    input_active = True
    player_name = stats.get('player_name', '–ò–≥—Ä–æ–∫')
    input_rect = pygame.Rect(WIDTH//2 - 150, 250, 300, 50)
    
    while input_active:
        screen.fill(DARK_BLUE)
        
        title = title_font.render('Serpent.io', True, GOLD)
        screen.blit(title, (WIDTH//2 - title.get_width()//2, 100))
        
        subtitle = large_font.render('–í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è:', True, WHITE)
        screen.blit(subtitle, (WIDTH//2 - subtitle.get_width()//2, 180))
        
        pygame.draw.rect(screen, WHITE, input_rect, 2, border_radius=5)
        pygame.draw.rect(screen, (30, 30, 70), input_rect.inflate(-4, -4), border_radius=4)
        
        name_text = normal_font.render(player_name, True, WHITE)
        screen.blit(name_text, (input_rect.x + 10, input_rect.y + 10))
        
        if draw_button(screen, '–ù–ê–ß–ê–¢–¨', WIDTH//2 - 75, 320, 150, 50, GREEN, LIGHT_GREEN, WHITE, normal_font):
            if player_name.strip():
                stats['player_name'] = player_name.strip()
                save_stats(stats)
                return
        
        creator_text = very_small_font.render('–°–æ–∑–¥–∞—Ç–µ–ª—å: –¶—ã–±–∏–Ω–∞ –ê.–ê.', True, SILVER)
        screen.blit(creator_text, (WIDTH//2 - creator_text.get_width()//2, HEIGHT - 30))
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    if player_name.strip():
                        stats['player_name'] = player_name.strip()
                        save_stats(stats)
                        return
                elif event.key == pygame.K_BACKSPACE:
                    player_name = player_name[:-1]
                elif event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                else:
                    if len(player_name) < 15 and event.unicode.isprintable():
                        player_name += event.unicode

def skin_selection_screen(stats):
    """–≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ —Å–∫–∏–Ω–æ–≤"""
    running = True
    current_page = 0
    skins_per_page = 6
    
    while running:
        screen.fill(DARK_BLUE)
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        title = title_font.render('–í–´–ë–û–† –°–ö–ò–ù–ê', True, GOLD)
        screen.blit(title, (WIDTH//2 - title.get_width()//2, 50))
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–æ–Ω–µ—Ç–∞—Ö
        coins_text = large_font.render(f'–ú–æ–Ω–µ—Ç—ã: {stats["coins"]}', True, GOLD)
        screen.blit(coins_text, (WIDTH - 250, 50))
        
        # –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–∫–∏–Ω–æ–≤ –Ω–∞ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
        start_idx = current_page * skins_per_page
        end_idx = min(start_idx + skins_per_page, len(SNAKE_SKINS))
        
        for i, skin_idx in enumerate(range(start_idx, end_idx)):
            skin = SNAKE_SKINS[skin_idx]
            row = i // 3
            col = i % 3
            x = WIDTH//2 - 400 + col * 270
            y = 150 + row * 200
            
            # –§–æ–Ω –¥–ª—è —Å–∫–∏–Ω–∞
            bg_color = LIGHT_BLUE if skin_idx == stats['selected_skin'] else (50, 50, 100)
            pygame.draw.rect(screen, bg_color, (x-10, y-10, 250, 180), border_radius=10)
            pygame.draw.rect(screen, WHITE, (x-10, y-10, 250, 180), 2, border_radius=10)
            
            # –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å–∫–∏–Ω–∞ –≤ –≤–∏–¥–µ –∑–º–µ–π–∫–∏
            draw_snake_preview(screen, x + 115, y + 50, skin)
            
            # –ù–∞–∑–≤–∞–Ω–∏–µ —Å–∫–∏–Ω–∞
            name_text = normal_font.render(skin['name'], True, WHITE)
            screen.blit(name_text, (x + 125 - name_text.get_width()//2, y + 90))
            
            # –¶–µ–Ω–∞ –∏–ª–∏ —Å—Ç–∞—Ç—É—Å
            if skin_idx in stats['unlocked_skins']:
                status_text = small_font.render('–†–ê–ó–ë–õ–û–ö–ò–†–û–í–ê–ù', True, GREEN)
                screen.blit(status_text, (x + 125 - status_text.get_width()//2, y + 120))
            else:
                price_text = small_font.render(f'–¶–µ–Ω–∞: {skin["price"]}', True, YELLOW)
                screen.blit(price_text, (x + 125 - price_text.get_width()//2, y + 120))
            
            # –û–ø–∏—Å–∞–Ω–∏–µ
            desc_text = very_small_font.render(skin['description'], True, SILVER)
            screen.blit(desc_text, (x + 125 - desc_text.get_width()//2, y + 140))
            
            # –ö–Ω–æ–ø–∫–∞ –≤—ã–±–æ—Ä–∞/–ø–æ–∫—É–ø–∫–∏
            button_text = "–í–´–ë–†–ê–¢–¨" if skin_idx in stats['unlocked_skins'] else "–ö–£–ü–ò–¢–¨"
            button_color = GREEN if skin_idx in stats['unlocked_skins'] else YELLOW
            hover_color = LIGHT_GREEN if skin_idx in stats['unlocked_skins'] else GOLD
            
            button_clicked = draw_button(screen, button_text, x + 75, y + 160, 80, 30, 
                                       button_color, hover_color, WHITE, very_small_font)
            
            if button_clicked:
                if skin_idx in stats['unlocked_skins']:
                    stats['selected_skin'] = skin_idx
                    save_stats(stats)
                else:
                    if unlock_skin(stats, skin_idx):
                        unlock_sound.play()
        
        # –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        if current_page > 0:
            if draw_button(screen, '‚Üê', 50, HEIGHT//2, 60, 60, BLUE, LIGHT_BLUE, WHITE, large_font):
                current_page -= 1
                pygame.time.delay(200)
        
        if (current_page + 1) * skins_per_page < len(SNAKE_SKINS):
            if draw_button(screen, '‚Üí', WIDTH - 110, HEIGHT//2, 60, 60, BLUE, LIGHT_BLUE, WHITE, large_font):
                current_page += 1
                pygame.time.delay(200)
        
        # –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥
        back_button_clicked = draw_button(screen, '–ù–ê–ó–ê–î', WIDTH//2 - 80, HEIGHT - 100, 160, 50, RED, PINK, WHITE, normal_font)
        
        if back_button_clicked:
            return
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return

def profile_screen(stats):
    running = True
    
    while running:
        screen.fill(DARK_BLUE)
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        title = title_font.render('–ü–†–û–§–ò–õ–¨ –ò–ì–†–û–ö–ê', True, GOLD)
        screen.blit(title, (WIDTH//2 - title.get_width()//2, 50))
        
        # –°–æ–∑–¥–∞—Ç–µ–ª—å –≤–Ω–∏–∑—É
        creator_text = very_small_font.render('–°–æ–∑–¥–∞—Ç–µ–ª—å: –¶—ã–±–∏–Ω–∞ –ê.–ê.', True, SILVER)
        screen.blit(creator_text, (WIDTH//2 - creator_text.get_width()//2, HEIGHT - 30))
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        stats_bg = pygame.Surface((700, 500), pygame.SRCALPHA)
        stats_bg.fill((0, 0, 0, 180))
        screen.blit(stats_bg, (WIDTH//2 - 350, 120))
        
        texts = [
            f'–ò–º—è: {stats["player_name"]}',
            f'–†–µ–π—Ç–∏–Ω–≥: {stats["rating"]}',
            f'–í—Å–µ–≥–æ –∏–≥—Ä: {stats["total_games"]}',
            f'–ü–æ–±–µ–¥: {stats["games_won"]}',
            f'–û–±—â–∏–π —Å—á–µ—Ç: {stats["total_score"]}',
            f'–†–µ–∫–æ—Ä–¥ —Å—á–µ—Ç–∞: {stats["max_score"]}',
            f'–í—Å–µ–≥–æ —É–±–∏–π—Å—Ç–≤: {stats["total_kills"]}',
            f'–†–µ–∫–æ—Ä–¥ —É–±–∏–π—Å—Ç–≤: {stats["max_kills"]}',
            f'–ú–æ–Ω–µ—Ç—ã: {stats["coins"]}',
            f'–°–∫–∏–Ω–æ–≤: {len(stats["unlocked_skins"])}/{len(SNAKE_SKINS)}'
        ]
        
        for i, text in enumerate(texts):
            color = GOLD if i == 0 else CYAN if '–†–µ–π—Ç–∏–Ω–≥' in text else YELLOW if '–†–µ–∫–æ—Ä–¥' in text else WHITE
            text_surf = normal_font.render(text, True, color)
            screen.blit(text_surf, (WIDTH//2 - 300, 150 + i * 40))
        
        # –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥
        back_button_clicked = draw_button(screen, '–ù–ê–ó–ê–î', WIDTH//2 - 100, 650, 200, 50, RED, PINK, WHITE, normal_font)
        
        if back_button_clicked:
            return
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return

def main_menu(stats):
    running = True
    game_mode = 0
    
    while running:
        screen.fill(DARK_BLUE)
        
        title = title_font.render('Serpent.io', True, GOLD)
        screen.blit(title, (WIDTH//2 - title.get_width()//2, 50))
        
        creator_text = very_small_font.render('–°–æ–∑–¥–∞—Ç–µ–ª—å: –¶—ã–±–∏–Ω–∞ –ê.–ê.', True, SILVER)
        screen.blit(creator_text, (WIDTH//2 - creator_text.get_width()//2, HEIGHT - 30))
        
        stats_bg = pygame.Surface((500, 200), pygame.SRCALPHA)
        stats_bg.fill((0, 0, 0, 150))
        screen.blit(stats_bg, (WIDTH//2 - 250, 120))
        
        welcome_text = large_font.render(f'–ü—Ä–∏–≤–µ—Ç, {stats["player_name"]}!', True, WHITE)
        rating_text = normal_font.render(f'–†–µ–π—Ç–∏–Ω–≥: {stats["rating"]}', True, CYAN)
        coins_text = normal_font.render(f'–ú–æ–Ω–µ—Ç—ã: {stats["coins"]}', True, GOLD)
        best_score = normal_font.render(f'–†–µ–∫–æ—Ä–¥: {stats["max_score"]}', True, YELLOW)
        
        screen.blit(welcome_text, (WIDTH//2 - welcome_text.get_width()//2, 140))
        screen.blit(rating_text, (WIDTH//2 - 230, 180))
        screen.blit(coins_text, (WIDTH//2 - 230, 220))
        screen.blit(best_score, (WIDTH//2 + 50, 180))
        
        button_width, button_height = 250, 50
        button_y = 350
        
        play_clicked = draw_button(screen, '–ò–ì–†–ê–¢–¨', WIDTH//2 - button_width - 20, button_y, button_width, button_height, 
                      GREEN, LIGHT_GREEN, WHITE, normal_font)
        
        skins_clicked = draw_button(screen, '–°–ö–ò–ù–´', WIDTH//2 + 20, button_y, button_width, button_height, 
                      BLUE, LIGHT_BLUE, WHITE, normal_font)
        
        profile_clicked = draw_button(screen, '–ü–†–û–§–ò–õ–¨', WIDTH//2 - button_width - 20, button_y + 70, button_width, button_height, 
                      PURPLE, MAGENTA, WHITE, normal_font)
        
        quit_clicked = draw_button(screen, '–í–´–•–û–î', WIDTH//2 + 20, button_y + 70, button_width, button_height, 
                      RED, PINK, WHITE, normal_font)
        
        if play_clicked:
            return 'play', stats['selected_skin'], game_mode
        
        if skins_clicked:
            skin_selection_screen(stats)
            continue
        
        if profile_clicked:
            profile_screen(stats)
            continue
        
        if quit_clicked:
            return 'quit', stats['selected_skin'], game_mode
        
        mode_text = small_font.render('–†–µ–∂–∏–º:', True, WHITE)
        screen.blit(mode_text, (WIDTH//2 - 150, button_y - 40))
        
        mode_name = GAME_MODES[game_mode]['name']
        mode_display = normal_font.render(mode_name, True, YELLOW)
        screen.blit(mode_display, (WIDTH//2 - mode_display.get_width()//2, button_y - 40))
        
        prev_clicked = draw_button(screen, '<', WIDTH//2 - 180, button_y - 40, 30, 30, PURPLE, CYAN, WHITE, small_font)
        next_clicked = draw_button(screen, '>', WIDTH//2 + 150, button_y - 40, 30, 30, PURPLE, CYAN, WHITE, small_font)
        
        if prev_clicked:
            game_mode = (game_mode - 1) % len(GAME_MODES)
            pygame.time.delay(200)
        if next_clicked:
            game_mode = (game_mode + 1) % len(GAME_MODES)
            pygame.time.delay(200)
        
        pygame.display.flip()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return 'quit', stats['selected_skin'], game_mode
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    return 'quit', stats['selected_skin'], game_mode
    
    return 'play', stats['selected_skin'], game_mode

def play_game(stats, selected_skin, game_mode):
    mode = GAME_MODES[game_mode]
    
    camera = Camera()
    player = Snake(MAP_WIDTH//2, MAP_HEIGHT//2, selected_skin, stats['player_name'], False, 4, mode['speed'] / 10.0)
    
    # –£–º–µ–Ω—å—à–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –µ–¥—ã –≤ 2 —Ä–∞–∑–∞
    foods = [Food() for _ in range(mode['food_amount'] // 2)]
    
    bots = []
    available_names = BOT_NAMES.copy()
    random.shuffle(available_names)
    
    # –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ —Å–æ–∑–¥–∞–µ–º 20 –±–æ—Ç–æ–≤
    initial_bots = min(20, len(available_names))
    for i in range(initial_bots):
        bot_name = available_names[i]
        bot = AdvancedBot(
            bot_name, 
            mode['bot_intelligence'], 
            mode['bot_speed'], 
            mode['bot_size_variation']
        )
        bots.append(bot)
    
    # –£–¥–∞–ª—è–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –∏–º–µ–Ω–∞
    available_names = available_names[initial_bots:]
    
    game_over = False
    score_multiplier = mode['score_multiplier']
    coins_earned = 0
    kills = 0
    start_time = time.time()
    bot_respawn_timer = 0
    bot_respawn_interval = 30  # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–∞–∂–¥—ã–µ 0.5 —Å–µ–∫—É–Ω–¥—ã
    food_respawn_timer = 0
    food_respawn_interval = 180  # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –µ–¥—ã –∫–∞–∂–¥—ã–µ 3 —Å–µ–∫—É–Ω–¥—ã
    
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                return False
                
            if event.type == pygame.KEYDOWN:
                if game_over:
                    if event.key == pygame.K_r:
                        return True
                    elif event.key == pygame.K_m:
                        return False
                    elif event.key == pygame.K_q:
                        return False
                else:
                    if event.key == pygame.K_UP:
                        player.change_direction((0, -1))
                    elif event.key == pygame.K_DOWN:
                        player.change_direction((0, 1))
                    elif event.key == pygame.K_LEFT:
                        player.change_direction((-1, 0))
                    elif event.key == pygame.K_RIGHT:
                        player.change_direction((1, 0))
                    elif event.key == pygame.K_ESCAPE:
                        stats['total_score'] += player.score
                        stats['total_games'] += 1
                        stats['total_kills'] += kills
                        stats['coins'] += coins_earned
                        stats['time_played'] += int(time.time() - start_time)
                        save_stats(stats)
                        return False
        
        if not game_over:
            head_x, head_y = player.get_head_position()
            camera.update(head_x, head_y, player.speed)
            
            player.move()
            
            all_snakes = [player] + [bot.snake for bot in bots]
            
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –±–æ—Ç–æ–≤ –∫–∞–∂–¥—ã–µ 0.5 —Å–µ–∫—É–Ω–¥—ã
            bot_respawn_timer += 1
            if bot_respawn_timer >= bot_respawn_interval:
                bot_respawn_timer = 0
                
                # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –∂–∏–≤—ã—Ö –±–æ—Ç–æ–≤
                alive_bots = sum(1 for bot in bots if bot.snake.is_alive)
                
                # –£–¥–∞–ª—è–µ–º –º–µ—Ä—Ç–≤—ã—Ö –±–æ—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —É–º–µ—Ä–ª–∏ –±–æ–ª–µ–µ 10 —Å–µ–∫—É–Ω–¥ –Ω–∞–∑–∞–¥
                current_time = time.time()
                bots = [bot for bot in bots if bot.snake.is_alive or current_time - bot.death_time < 10]
                
                # –ï—Å–ª–∏ –∂–∏–≤—ã—Ö –±–æ—Ç–æ–≤ –º–µ–Ω—å—à–µ 20 –∏ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ–Ω—å—à–µ 40, –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã—Ö
                if alive_bots < 20 and len(bots) < 40:
                    # –ï—Å–ª–∏ –∏–º–µ–Ω–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å, –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –∑–∞–Ω–æ–≤–æ
                    if not available_names:
                        available_names = BOT_NAMES.copy()
                        random.shuffle(available_names)
                        # –£–¥–∞–ª—è–µ–º –∏–º–µ–Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –±–æ—Ç–æ–≤
                        existing_names = {bot.snake.name for bot in bots if bot.snake.is_alive}
                        available_names = [name for name in available_names if name not in existing_names]
                    
                    if available_names:
                        bot_name = available_names.pop(0)
                        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –±–æ—Ç–∞ –≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ–º –º–µ—Å—Ç–µ (–ø–æ–¥–∞–ª—å—à–µ –æ—Ç –≥—Ä–∞–Ω–∏—Ü)
                        safe_margin = 800  # –û—Ç—Å—Ç—É–ø –æ—Ç –≥—Ä–∞–Ω–∏—Ü –∫–∞—Ä—Ç—ã
                        x = random.randint(safe_margin, MAP_WIDTH - safe_margin)
                        y = random.randint(safe_margin, MAP_HEIGHT - safe_margin)
                        
                        bot = AdvancedBot(
                            bot_name, 
                            mode['bot_intelligence'], 
                            mode['bot_speed'], 
                            mode['bot_size_variation']
                        )
                        # –ü–µ—Ä–µ–º–µ—â–∞–µ–º –±–æ—Ç–∞ –≤ –±–µ–∑–æ–ø–∞—Å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                        bot.snake.positions = [(x, y)]
                        for i in range(1, bot.snake.length):
                            new_x = x - i * bot.snake.direction[0] * GRID_SIZE
                            new_y = y - i * bot.snake.direction[1] * GRID_SIZE
                            bot.snake.positions.append((new_x, new_y))
                        
                        bots.append(bot)
            
            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –µ–¥—ã, –µ—Å–ª–∏ –µ–µ —Å—Ç–∞–ª–æ —Å–ª–∏—à–∫–æ–º –º–∞–ª–æ
            food_respawn_timer += 1
            if food_respawn_timer >= food_respawn_interval and len(foods) < mode['food_amount'] // 3:
                food_respawn_timer = 0
                # –î–æ–±–∞–≤–ª—è–µ–º –µ–¥—É —Ç–æ–ª—å–∫–æ –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏ –∫–∞—Ä—Ç—ã
                center_margin = 1000
                for _ in range(5):  # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ 5 –µ–¥—ã –∑–∞ —Ä–∞–∑
                    x = random.randint(center_margin, MAP_WIDTH - center_margin)
                    y = random.randint(center_margin, MAP_HEIGHT - center_margin)
                    foods.append(Food(position=(x, y)))
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–æ—Ç–æ–≤
            for bot in bots:
                bot.update(foods, player, bots)
                
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –±–æ—Ç –±–ª–∏–∑–∫–æ –∫ –≥—Ä–∞–Ω–∏—Ü–µ, –º–µ–Ω—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                if bot.snake.is_alive:
                    head_x, head_y = bot.snake.get_head_position()
                    border_margin = 300
                    
                    if (head_x < border_margin and bot.snake.direction[0] == -1) or \
                       (head_x > MAP_WIDTH - border_margin and bot.snake.direction[0] == 1) or \
                       (head_y < border_margin and bot.snake.direction[1] == -1) or \
                       (head_y > MAP_HEIGHT - border_margin and bot.snake.direction[1] == 1):
                        # –ó–∞—Å—Ç–∞–≤–ª—è–µ–º –±–æ—Ç–∞ –ø–æ–≤–µ—Ä–Ω—É—Ç—å –æ—Ç –≥—Ä–∞–Ω–∏—Ü—ã
                        new_directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
                        current_dir = bot.snake.direction
                        opposite_dir = (-current_dir[0], -current_dir[1])
                        # –ò—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–µ–µ –∏ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                        valid_dirs = [d for d in new_directions if d != current_dir and d != opposite_dir]
                        if valid_dirs:
                            bot.snake.change_direction(random.choice(valid_dirs))
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –µ–¥—ã
            for food in foods:
                food.update()
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π –∏–≥—Ä–æ–∫–∞ —Å –µ–¥–æ–π
            for food in foods[:]:
                fx, fy = food.position
                hx, hy = player.get_head_position()
                distance = math.hypot(fx - hx, fy - hy)
                
                if distance < GRID_SIZE * 1.5:
                    if food.type == 'coin':
                        coins_earned += food.value['coin']
                        coin_sound.play()
                    else:
                        player.grow(food.value[food.type] * score_multiplier)
                        if food.type == 'boost':
                            player.apply_boost()
                    
                    foods.remove(food)
                    # –ù–æ–≤–∞—è –µ–¥–∞ –ø–æ—è–≤–ª—è–µ—Ç—Å—è –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏
                    center_margin = 1000
                    x = random.randint(center_margin, MAP_WIDTH - center_margin)
                    y = random.randint(center_margin, MAP_HEIGHT - center_margin)
                    foods.append(Food(position=(x, y)))
                    break
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–Ω–≥–æ–≤
            alive_snakes = [s for s in all_snakes if s.is_alive]
            alive_snakes.sort(key=lambda x: x.score, reverse=True)
            
            for i, snake in enumerate(alive_snakes):
                snake.rank = i + 1
            
            # –ü–†–û–í–ï–†–ö–ê –°–¢–û–õ–ö–ù–û–í–ï–ù–ò–ô –ú–ï–ñ–î–£ –í–°–ï–ú–ò –ó–ú–ï–ô–ö–ê–ú–ò
            for i, snake1 in enumerate(all_snakes):
                if not snake1.is_alive or snake1.is_invincible():
                    continue
                    
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –≥–æ–ª–æ–≤—ã —Å —Ç–µ–ª–∞–º–∏ –¥—Ä—É–≥–∏—Ö –∑–º–µ–π
                hx1, hy1 = snake1.get_head_position()
                
                for snake2 in all_snakes:
                    if snake1 == snake2 or not snake2.is_alive:
                        continue
                    
                    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ–≥–º–µ–Ω—Ç–æ–≤ —Ç–µ–ª–∞ snake2
                    for j, (bx, by) in enumerate(snake2.positions):
                        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≥–æ–ª–æ–≤—É (–æ–Ω–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ)
                        if j == 0:
                            continue
                            
                        distance = math.hypot(hx1 - bx, hy1 - by)
                        if distance < GRID_SIZE * 0.8:
                            # –õ—é–±–∞—è –∑–º–µ–π–∫–∞ —É–º–∏—Ä–∞–µ—Ç –ø—Ä–∏ –∫–∞—Å–∞–Ω–∏–∏ —Ç–µ–ª–∞ –¥—Ä—É–≥–æ–π –∑–º–µ–π–∫–∏
                            food_dropped = snake1.kill()
                            if food_dropped:
                                # –°–æ–∑–¥–∞–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—É—é –µ–¥—É –Ω–∞ –º–µ—Å—Ç–µ —Å–º–µ—Ä—Ç–∏
                                for _ in range(food_dropped):
                                    foods.append(Food(position=snake1.get_head_position(), is_special=True))
                            
                            # –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ —É–±–∏–ª –∫–æ–≥–æ-—Ç–æ –∏–ª–∏ –±—ã–ª —É–±–∏—Ç
                            if snake1 == player:
                                kills += 1
                                kill_sound.play()
                            elif snake2 == player:
                                kills += 1
                                kill_sound.play()
                            break
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è –≥–æ–ª–æ–≤—ã —Å –≥–æ–ª–æ–≤–æ–π
                for snake2 in all_snakes:
                    if snake1 == snake2 or not snake2.is_alive or snake2.is_invincible():
                        continue
                    
                    hx2, hy2 = snake2.get_head_position()
                    distance = math.hypot(hx1 - hx2, hy1 - hy2)
                    
                    if distance < GRID_SIZE * 0.8:
                        if snake1.score > snake2.score * 1.2:
                            food_dropped = snake2.kill()
                            if food_dropped:
                                for _ in range(food_dropped):
                                    foods.append(Food(position=snake2.get_head_position(), is_special=True))
                            
                            if snake1 == player:
                                kills += 1
                                kill_sound.play()
                        elif snake2.score > snake1.score * 1.2:
                            food_dropped = snake1.kill()
                            if food_dropped:
                                for _ in range(food_dropped):
                                    foods.append(Food(position=snake1.get_head_position(), is_special=True))
                            
                            if snake2 == player:
                                kills += 1
                                kill_sound.play()
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–º–µ—Ä—Ç–∏ –∏–≥—Ä–æ–∫–∞
            if not player.is_alive:
                game_over = True
                final_rank = player.rank
                stats['time_played'] += int(time.time() - start_time)
            
            # –û—Ç—Ä–∏—Å–æ–≤–∫–∞
            draw_dynamic_background(screen, camera)
            
            # –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –µ–¥—ã
            for food in foods:
                food.draw(screen, camera)
            
            # –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –±–æ—Ç–æ–≤
            for bot in bots:
                bot.snake.draw(screen, camera)
            
            # –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∏–≥—Ä–æ–∫–∞
            player.draw(screen, camera)
            
            # HUD —Å —Ç–∞–±–ª–∏—Ü–µ–π –ª–∏–¥–µ—Ä–æ–≤
            alive_count = sum(1 for bot in bots if bot.snake.is_alive) + (1 if player.is_alive else 0)
            show_hud(screen, player.score, player.speed, player.boost_timer, 
                    player.name, kills, coins_earned, stats['coins'] + coins_earned, 
                    player.rank, alive_count, all_snakes, len(bots))
            
        else:
            # –≠–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã
            show_game_over(screen, player.score, player.name, kills, coins_earned, final_rank, stats)
        
        pygame.display.flip()
        clock.tick(60)
    
    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    if not game_over:
        stats['total_score'] += player.score
        stats['total_games'] += 1
        stats['total_kills'] += kills
        stats['coins'] += coins_earned
        stats['time_played'] += int(time.time() - start_time)
        save_stats(stats)
    
    return False
def main():
    stats = load_stats()
    
    get_player_name(stats)
    stats = load_stats()
    
    game_running = True
    while game_running:
        action, selected_skin, game_mode = main_menu(stats)
        
        if action == 'quit':
            game_running = False
        elif action == 'profile':
            profile_screen(stats)
        elif action == 'play':
            restart = play_game(stats, selected_skin, game_mode)
            if not restart:
                continue
    
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
    print("–ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–ø—É—â–µ–Ω–∞!")
